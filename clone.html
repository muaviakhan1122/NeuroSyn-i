<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aurora - Smart Assistant</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.0/mammoth.browser.min.js"></script>
    <style>
        :root {
            --primary: #6c5ce7;
            --primary-dark: #5649c0;
            --secondary: #00cec9;
            --accent: #fd79a8;
            --dark: #2d3436;
            --darker: #1e272e;
            --light: #f5f6fa;
            --light-gray: #dfe6e9;
            --success: #00b894;
            --warning: #fdcb6e;
            --error: #d63031;
            --info: #0984e3;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--darker);
            color: var(--light);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 250px;
            background-color: var(--dark);
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            z-index: 10;
        }

        .app-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
            margin: 15px 0 10px;
        }

        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .action-btn {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            background-color: rgba(108, 92, 231, 0.1);
            color: var(--light);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .action-btn i {
            margin-right: 10px;
            font-size: 16px;
        }

        .action-btn:hover {
            background-color: rgba(108, 92, 231, 0.3);
            transform: translateX(5px);
        }

        .action-btn.active {
            background-color: var(--primary);
        }

        .sidebar-footer {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .theme-selector {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: none;
            margin-top: 15px;
            cursor: pointer;
        }

        /* Main Content Styles */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            padding: 15px 25px;
            background-color: rgba(45, 52, 54, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 600;
        }

        .chat-actions {
            display: flex;
            gap: 15px;
        }

        .chat-action-btn {
            background: none;
            border: none;
            color: var(--light);
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .chat-action-btn:hover {
            color: var(--primary);
        }

        .chat-container {
            flex: 1;
            padding: 20px 25px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .chat-messages {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .message {
            max-width: 70%;
            padding: 15px 20px;
            border-radius: 18px;
            position: relative;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-message {
            align-self: flex-end;
            background-color: var(--primary);
            color: white;
            border-bottom-right-radius: 5px;
        }

        .assistant-message {
            align-self: flex-start;
            background-color: rgba(255, 255, 255, 0.1);
            border-bottom-left-radius: 5px;
        }

        .system-message {
            align-self: center;
            background-color: var(--warning);
            color: var(--dark);
            max-width: 90%;
            text-align: center;
            font-size: 14px;
        }

        .error-message {
            background-color: var(--error);
            color: white;
        }

        .message-content {
            font-size: 15px;
            line-height: 1.5;
        }

        .message-content b {
            font-weight: 600;
            color: var(--secondary);
        }

        .message-content strong {
            font-weight: 700;
            color: var(--accent);
        }

        .message-content p {
            margin-bottom: 10px;
        }

        .message-content ul,
        .message-content ol {
            margin-left: 20px;
            margin-bottom: 10px;
        }

        .message-content li {
            margin-bottom: 5px;
        }

        .message-meta {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.7;
        }

        /* Code block styles */
        .code-block {
            position: relative;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            overflow-x: auto;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }

        .copy-btn {
            background-color: rgba(108, 92, 231, 0.3);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 3px 8px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background-color: var(--primary);
        }

        .copy-btn.copied {
            background-color: var(--success);
        }

        /* Image generation styles */
        .generated-image {
            max-width: 100%;
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .image-prompt {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            font-style: italic;
        }

        /* Input Area Styles */
        .input-area {
            padding: 15px 25px;
            background-color: rgba(45, 52, 54, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .input-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 15px 20px;
            border-radius: 50px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 15px;
            outline: none;
            transition: all 0.3s ease;
        }

        .message-input:focus {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .input-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .input-btn:hover {
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }

        .input-btn.secondary {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .input-btn.secondary:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .input-btn.active {
            background-color: var(--error);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background-color: var(--dark);
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--light);
            font-size: 20px;
            cursor: pointer;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
        }

        .history-list {
            list-style: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .history-item-role {
            font-weight: 600;
            color: var(--primary);
            margin-right: 10px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 70px;
                padding: 15px 10px;
            }
            
            .app-title, .section-title, .action-btn span {
                display: none;
            }
            
            .action-btn {
                justify-content: center;
                padding: 12px;
            }
            
            .action-btn i {
                margin-right: 0;
                font-size: 18px;
            }
            
            .message {
                max-width: 85%;
            }
            
            .input-container {
                gap: 5px;
            }
            
            .message-input {
                padding: 12px 15px;
            }
            
            .input-btn {
                width: 45px;
                height: 45px;
            }
        }

        @media (max-width: 480px) {
            .chat-header {
                padding: 12px 15px;
            }
            
            .chat-container {
                padding: 15px;
            }
            
            .input-area {
                padding: 12px 15px;
            }
            
            .message {
                max-width: 90%;
                padding: 12px 15px;
            }
        }

        /* Animation */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .floating {
            animation: float 3s ease-in-out infinite;
        }

        /* Loading spinner */
        .spinner {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Typing indicator */
        .typing-indicator {
            display: flex;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 18px;
            align-self: flex-start;
            margin-bottom: 20px;
            border-bottom-left-radius: 5px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            margin: 0 3px;
            background-color: var(--light);
            border-radius: 50%;
            opacity: 0.4;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typingAnimation {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-5px); opacity: 1; }
        }

        /* File upload button */
        .input-btn.file-upload {
            position: relative;
            overflow: hidden;
        }

        .input-btn.file-upload input[type="file"] {
            position: absolute;
            top: 0;
            right: 0;
            min-width: 100%;
            min-height: 100%;
            font-size: 100px;
            text-align: right;
            filter: alpha(opacity=0);
            opacity: 0;
            outline: none;
            background: white;
            cursor: inherit;
            display: block;
        }

        /* Reasoning indicators */
        .reasoning-step {
            padding: 10px;
            margin: 5px 0;
            background: rgba(108, 92, 231, 0.1);
            border-radius: 8px;
            border-left: 3px solid var(--primary);
        }

        .reasoning-header {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 5px;
        }

        /* File preview */
        .file-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .file-info {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }
        /*Auth modal*/ 
        .auth-modal {
            max-width: 400px;
        }
        
        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .auth-toggle {
            margin-top: 15px;
            text-align: center;
            font-size: 14px;
        }
        
        .auth-toggle span {
            color: var(--primary);
            cursor: pointer;
            text-decoration: underline;
        }
        
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
        }
        
        .user-menu {
            position: absolute;
            top: 60px;
            right: 20px;
            background-color: var(--dark);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 10px 0;
            width: 200px;
            z-index: 1000;
            display: none;
        }
        
        .user-menu.active {
            display: block;
        }
        
        .user-menu-item {
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .user-menu-item:hover {
            background-color: rgba(255,255,255,0.1);
        }
        
        .file-context {
            font-size: 13px;
            color: rgba(255,255,255,0.7);
            margin-top: 5px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            display: inline-block;
        }

        /* Image generation button */
        .generate-image-btn {
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            margin-top: 10px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .generate-image-btn:hover {
            background-color: #e84393;
        }
        html, body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        }

        .app-container {
        height: 100vh !important;
        width: 100vw !important;
        }

        .sidebar, .main-content {
        height: 100% !important;
        }

        .chat-container {
        flex: 1;
        min-height: 0; /* Fix for Firefox scrolling */
        }

        /* Force visibility of critical elements */
        #appContainer {
        display: flex !important;
        opacity: 1 !important;
        visibility: visible !important;
        }
        /*history modal*/ 
        .history-sessions {
            list-style: none;
            padding: 0;
        }

        .history-session {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .history-session:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .history-session-title {
            font-weight: 600;
        }

        .history-session-timestamp {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Webcam modal styles */
        .webcam-modal {
            max-width: 800px;
        }

        .webcam-container {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }

        .webcam-video {
            width: 100%;
            border-radius: 8px;
            background-color: #000;
        }

        .webcam-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .webcam-btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .webcam-btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .webcam-btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .webcam-btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .webcam-btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .webcam-status {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: var(--secondary);
        }

        /* Theming Styles */
        body.light {
            --dark: #f5f6fa;
            --darker: #dfe6e9;
            --light: #2d3436;
            /* ... adjust other colors as needed ... */
        }

        body.blue {
            --primary: #2980b9;
            --primary-dark: #2471a3;
            /* ... other color adjustments ... */
        }

        body.green {
            --primary: #27ae60;
            --primary-dark: #219653;
            /* ... other color adjustments ... */
        }
    </style>
</head>
<body>
    <div class="app-container" id="appContainer">
        <!-- Add login/signup modals -->
    <div class="modal-overlay" id="loginModal">
        <div class="modal auth-modal">
            <div class="modal-header">
                <div class="modal-title">Login to Aurora</div>
                <button class="modal-close" onclick="hideModal('loginModal')">&times;</button>
            </div>
            <div class="modal-body">
                <form class="auth-form" id="loginForm">
                    <div class="form-group">
                        <label class="form-label">Email</label>
                        <input type="email" class="form-control" id="loginEmail" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Password</label>
                        <input type="password" class="form-control" id="loginPassword" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Login</button>
                </form>
                <div class="auth-toggle">
                    Don't have an account? <span onclick="showSignupModal()">Sign up</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="signupModal">
        <div class="modal auth-modal">
            <div class="modal-header">
                <div class="modal-title">Create Account</div>
                <button class="modal-close" onclick="hideModal('signupModal')">&times;</button>
            </div>
            <div class="modal-body">
                <form class="auth-form" id="signupForm">
                    <div class="form-group">
                        <label class="form-label">Name</label>
                        <input type="text" class="form-control" id="signupName" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Email</label>
                        <input type="email" class="form-control" id="signupEmail" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Password</label>
                        <input type="password" class="form-control" id="signupPassword" required minlength="6">
                    </div>
                    <button type="submit" class="btn btn-primary">Sign Up</button>
                </form>
                <div class="auth-toggle">
                    Already have an account? <span onclick="showLoginModal()">Login</span>
                </div>
            </div>
        </div>
    </div>  

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="app-title">Aurora</div>
            
            <div class="section-title">Quick Actions</div>
            <div class="quick-actions">
                <button class="action-btn" onclick="handleQuickAction('google')">
                    <i class="fas fa-search"></i>
                    <span>Google</span>
                </button>
                <button class="action-btn" onclick="handleQuickAction('youtube')">
                    <i class="fab fa-youtube"></i>
                    <span>YouTube</span>
                </button>
                <button class="action-btn" onclick="handleQuickAction('weather')">
                    <i class="fas fa-cloud-sun"></i>
                    <span>Weather</span>
                </button>
                <button class="action-btn" onclick="handleQuickAction('news')">
                    <i class="far fa-newspaper"></i>
                    <span>News</span>
                </button>
                <button class="action-btn" onclick="handleQuickAction('webcam')">
                    <i class="fas fa-camera"></i>
                    <span>Webcam</span>
                </button>
                <button class="action-btn" onclick="handleQuickAction('settings')">
                    <i class="fas fa-cog"></i>
                    <span>Settings</span>
                </button>
            </div>
            
            <div class="sidebar-footer">
                <button class="action-btn" onclick="showHistoryModal()">
                    <i class="fas fa-history"></i>
                    <span>History</span>
                </button>
                <button class="action-btn" onclick="showPreferencesModal()">
                    <i class="fas fa-sliders-h"></i>
                    <span>Preferences</span>
                </button>
                
                <select class="theme-selector" id="themeSelector" onchange="changeTheme(this.value)">
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                    <option value="blue">Blue</option>
                    <option value="green">Green</option>
                </select>
            </div>
    </div>     
        <!-- Main Content -->
        <div class="main-content">
            <div class="chat-header">
                <div class="chat-title">New Chat</div>
                <div class="chat-actions">
                    <div class="user-avatar" id="userAvatar" onclick="toggleUserMenu()"></div>
                    <div class="user-menu" id="userMenu">
                        <div class="user-menu-item" onclick="showPreferencesModal()">
                            <i class="fas fa-cog"></i> Preferences
                        </div>
                        <div class="user-menu-item" onclick="logout()">
                            <i class="fas fa-sign-out-alt"></i> Logout
                        </div>
                    </div>
                    <button class="chat-action-btn" onclick="clearChat()">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                    <button class="chat-action-btn" onclick="toggleFullscreen()">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div> 
            
            <div class="chat-container" id="chatContainer">
                <div class="chat-messages" id="chatMessages">
                    <!-- Messages will be added here dynamically -->
                </div>
            </div>
            
            <div class="input-area">
                <div class="input-container">
                    <label for="fileUpload" class="input-btn secondary" title="Upload File">
                        <i class="fas fa-file-upload"></i>
                        <input type="file" id="fileUpload" style="display: none;" onchange="handleFileUpload(this.files)">
                    </label>
                    <input type="text" class="message-input" id="messageInput" placeholder="Type your message here..." onkeypress="handleKeyPress(event)">
                    <button class="input-btn secondary" id="voiceBtn" onclick="toggleVoiceInput()">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button class="input-btn" id="sendBtn" onclick="sendMessage()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div> 
    
    <!-- History Modal -->
    <div class="modal-overlay" id="historyModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Conversation History</div>
                <button class="modal-close" onclick="hideModal('historyModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <button class="btn btn-primary" onclick="createNewSession()">
                        <i class="fas fa-plus"></i> New Chat
                    </button>
                </div>
                <ul class="history-list" id="historyList">
                    <!-- History items will be added here -->
                </ul>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideModal('historyModal')">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Preferences Modal -->
    <div class="modal-overlay" id="preferencesModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Preferences</div>
                <button class="modal-close" onclick="hideModal('preferencesModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Response Length</label>
                    <select class="form-control" id="responseLength">
                        <option value="short">Short</option>
                        <option value="medium">Medium</option>
                        <option value="long">Long</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Formality Level</label>
                    <select class="form-control" id="formalityLevel">
                        <option value="casual">Casual</option>
                        <option value="neutral">Neutral</option>
                        <option value="formal">Formal</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Preferred AI</label>
                    <select class="form-control" id="preferredAI">
                        <option value="gemini">Gemini</option>
                        <option value="anthropic">Anthropic</option>
                        <option value="hybrid">Hybrid</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Reasoning Mode</label>
                    <select class="form-control" id="reasoningMode">
                        <option value="fast">Fast Response</option>
                        <option value="balanced">Balanced</option>
                        <option value="deep">Deep Reasoning</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Favorite Topics (comma separated)</label>
                    <input type="text" class="form-control" id="favoriteTopics" placeholder="e.g. technology, science, music">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideModal('preferencesModal')">Cancel</button>
                <button class="btn btn-primary" onclick="savePreferences()">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Weather Modal -->
    <div class="modal-overlay" id="weatherModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Weather Information</div>
                <button class="modal-close" onclick="hideModal('weatherModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Enter city name</label>
                    <input type="text" class="form-control" id="weatherCity" placeholder="e.g. New York">
                </div>
                <div id="weatherResult"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideModal('weatherModal')">Close</button>
                <button class="btn btn-primary" onclick="fetchWeather()">Get Weather</button>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Settings</div>
                <button class="modal-close" onclick="hideModal('settingsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Speech Rate</label>
                    <input type="range" class="form-control" id="speechRate" min="0.5" max="2" step="0.1" value="1">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Speech Volume</label>
                    <input type="range" class="form-control" id="speechVolume" min="0" max="1" step="0.1" value="0.8">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Voice</label>
                    <select class="form-control" id="voiceSelect">
                        <option value="default">Default</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideModal('settingsModal')">Close</button>
                <button class="btn btn-primary" onclick="saveSettings()">Save</button>
            </div>
        </div>
    </div>

    <!-- Webcam Modal -->
    <div class="modal-overlay" id="webcamModal">
        <div class="modal webcam-modal">
            <div class="modal-header">
                <div class="modal-title">Webcam Interaction</div>
                <button class="modal-close" onclick="stopWebcam(); hideModal('webcamModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="webcam-container">
                    <video id="webcamVideo" class="webcam-video" autoplay playsinline></video>
                </div>
                <div class="webcam-status" id="webcamStatus">Click "Start Webcam" to begin</div>
                <div class="webcam-controls">
                    <button class="webcam-btn webcam-btn-primary" id="startWebcamBtn" onclick="startWebcam()">
                        <i class="fas fa-video"></i> Start Webcam
                    </button>
                    <button class="webcam-btn webcam-btn-secondary" id="stopWebcamBtn" onclick="stopWebcam()" disabled>
                        <i class="fas fa-stop"></i> Stop Webcam
                    </button>
                </div>
                <div class="form-group" style="margin-top: 20px;">
                    <label class="form-label">Webcam Mode</label>
                    <select class="form-control" id="webcamMode">
                        <option value="voice">Voice Interaction</option>
                        <option value="gesture">Gesture Recognition</option>
                        <option value="both">Voice + Gesture</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="stopWebcam(); hideModal('webcamModal')">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration - Replace these with your actual API keys
        const CONFIG = {
            newsapi: "0f8c1818fae645ffb632113d9d04aa74", 
            weather_api: "a93488f223194895ac045648250402",
            genai_key: "AIzaSyBygYbUpztuT76GkpEigtIelEX_nJRBAkg", 
            anthropic_key: "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",
            stabilityai_key: "sk-your-stability-ai-key" // Replace with actual Stability AI key
        };

        // Supported file types for upload
        const SUPPORTED_FILE_TYPES = {
            'application/pdf': 'PDF',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'Word',
            'text/plain': 'Text',
            'image/jpeg': 'Image',
            'image/png': 'Image'
        };

        // State
        let currentSessionID = null;
        let chatSessions = {};
        let currentUser = null;
        let conversationHistory = [];
        let currentFileContext = null;
        let userPreferences = {
            response_length: "medium",
            formality: "neutral",
            topics: [],
            last_session: null,
            ongoing_topics: {},
            preferred_ai: "hybrid",
            reasoning_mode: "balanced"
        };
        
        let isListening = false;
        let recognition;
        let speechSynthesis = window.speechSynthesis;
        let voices = [];
        let currentTheme = "dark";
        let isMobile = /Mobi|Android/i.test(navigator.userAgent);

        // Webcam state
        let webcamStream = null;
        let isWebcamActive = false;
        let webcamInterval = null;
        let webcamMode = 'voice';

        // DOM Elements
        const appContainer = document.getElementById('appContainer');
        const userAvatar = document.getElementById('userAvatar');
        const userMenu = document.getElementById('userMenu');
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const voiceBtn = document.getElementById('voiceBtn');
        const responseLength = document.getElementById('responseLength');
        const formalityLevel = document.getElementById('formalityLevel');
        const preferredAI = document.getElementById('preferredAI');
        const favoriteTopics = document.getElementById('favoriteTopics');
        const reasoningMode = document.getElementById('reasoningMode');
        const themeSelector = document.getElementById('themeSelector');
        const chatContainer = document.getElementById('chatContainer');
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamStatus = document.getElementById('webcamStatus');
        const startWebcamBtn = document.getElementById('startWebcamBtn');
        const stopWebcamBtn = document.getElementById('stopWebcamBtn');
        const webcamModeSelect = document.getElementById('webcamMode');

        // Initialize the app
        function init() {
            // Check if user is already logged in
            checkAuthState();
            ensureUIVisible();
            // Set up auth forms
            loginForm.addEventListener('submit', handleLogin);
            signupForm.addEventListener('submit', handleSignup);
            
            // Initialize PDF.js
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
            
            // Add welcome message if not logged in
            if (!currentUser) {
                addMessage('assistant', 'Hello! I\'m Aurora, your smart assistant. Please login or sign up to continue.');
            }
            
            // Load chat sessions
            loadChatSessions();

            // Create new session if none exist
            if (!currentSessionID) {
                createNewSession();
            } else {
                loadSession(currentSessionID);
            }

            // Setup voice recognition and synthesis
            setupSpeechRecognition();
            setupSpeechSynthesis();
        }

        // Load chat sessions from localStorage
        function loadChatSessions() {
            if (!currentUser) return;
            
            const savedSessions = localStorage.getItem(`aurora_sessions_${currentUser.id}`);
            if (savedSessions) {
                chatSessions = JSON.parse(savedSessions);
                
                // Sort sessions by last active time (newest first)
                const sortedSessions = Object.values(chatSessions).sort((a, b) => 
                    new Date(b.lastActive) - new Date(a.lastActive)
                );
                
                // Set the most recent session as current
                if (sortedSessions.length > 0) {
                    currentSessionID = sortedSessions[0].id;
                }
            }
        }

        // Create a new chat session
        function createNewSession() {
            const newSessionID = generateUUID();
            const sessionTitle = `Chat ${Object.keys(chatSessions).length + 1}`;
            
            chatSessions[newSessionID] = {
                id: newSessionID,
                title: sessionTitle,
                history: [],
                lastActive: new Date().toISOString(),
                createdAt: new Date().toISOString()
            };
            
            currentSessionID = newSessionID;
            saveChatSessions();
            updateHistoryModal();
            loadSession(newSessionID);
            
            // Update chat title
            document.querySelector('.chat-title').textContent = sessionTitle;
            
            return newSessionID;
        }

        // Generate UUID for sessions
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Load a specific chat session
        function loadSession(sessionID) {
            const session = chatSessions[sessionID];
            if (session) {
                conversationHistory = session.history || [];
                currentSessionID = sessionID;
                
                // Update chat title
                document.querySelector('.chat-title').textContent = session.title;
                
                // Render messages
                renderMessages();
                
                // Update last active timestamp
                chatSessions[currentSessionID].lastActive = new Date().toISOString();
                saveChatSessions();
            } else {
                console.error("Session not found:", sessionID);
            }
        }

        // Save all chat sessions to localStorage
        function saveChatSessions() {
            if (currentUser) {
                localStorage.setItem(`aurora_sessions_${currentUser.id}`, JSON.stringify(chatSessions));
            }
        }

        // Delete a chat session
        function deleteSession(sessionID) {
            if (confirm('Are you sure you want to delete this chat session?')) {
                delete chatSessions[sessionID];
                saveChatSessions();
                
                // If we're deleting the current session, switch to another or create new
                if (sessionID === currentSessionID) {
                    const remainingSessions = Object.keys(chatSessions);
                    if (remainingSessions.length > 0) {
                        loadSession(remainingSessions[0]);
                    } else {
                        createNewSession();
                    }
                }
                
                updateHistoryModal();
            }
        }

        // Update the history modal with all sessions
        function updateHistoryModal() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            
            // Sort sessions by last active (newest first)
            const sortedSessions = Object.values(chatSessions).sort((a, b) => 
                new Date(b.lastActive) - new Date(a.lastActive)
            );
            
            sortedSessions.forEach(session => {
                const sessionItem = document.createElement('li');
                sessionItem.className = 'history-session';
                sessionItem.dataset.sessionId = session.id;
                
                const sessionTitle = document.createElement('div');
                sessionTitle.className = 'history-session-title';
                sessionTitle.textContent = session.title;
                
                const sessionTimestamp = document.createElement('div');
                sessionTimestamp.className = 'history-session-timestamp';
                sessionTimestamp.textContent = new Date(session.lastActive).toLocaleString();
                
                const sessionActions = document.createElement('div');
                sessionActions.className = 'history-session-actions';
                
                const loadBtn = document.createElement('button');
                loadBtn.className = 'btn btn-small btn-primary';
                loadBtn.innerHTML = '<i class="fas fa-comments"></i>';
                loadBtn.title = 'Load this chat';
                loadBtn.onclick = (e) => {
                    e.stopPropagation();
                    loadSession(session.id);
                    hideModal('historyModal');
                };
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-small btn-secondary';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Delete this chat';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteSession(session.id);
                };
                
                sessionActions.appendChild(loadBtn);
                sessionActions.appendChild(deleteBtn);
                
                sessionItem.appendChild(sessionTitle);
                sessionItem.appendChild(sessionTimestamp);
                sessionItem.appendChild(sessionActions);
                
                historyList.appendChild(sessionItem);
            });
        }

        // Render all messages in the current session
        function renderMessages() {
            chatMessages.innerHTML = '';
            
            conversationHistory.forEach(message => {
                addMessage(message.role, message.content, false, false);
            });
            
            scrollToBottom();
        }

        // Check authentication state from localStorage
        function checkAuthState() {
            const userData = localStorage.getItem('aurora_user');
            if (userData) {
                currentUser = JSON.parse(userData);
                userAvatar.textContent = currentUser.name ? currentUser.name.charAt(0).toUpperCase() : currentUser.email.charAt(0).toUpperCase();
                appContainer.style.display = 'flex';
                
                // Load user data
                loadUserData();
                
                // Add welcome message
                addMessage('assistant', `Welcome back, ${currentUser.name || 'User'}! How can I assist you today?`);
            } else {
                // No user signed in
                currentUser = null;
                appContainer.style.display = 'none';
                showLoginModal();
            }
        }

        // Auth functions
        function handleLogin(e) {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            // Get users from localStorage
            const users = JSON.parse(localStorage.getItem('aurora_users')) || [];
            const user = users.find(u => u.email === email && u.password === password);
            
            if (user) {
                // Successful login
                currentUser = {
                    email: user.email,
                    name: user.name,
                    id: user.id
                };
                
                // Save current user to localStorage
                localStorage.setItem('aurora_user', JSON.stringify(currentUser));
                
                // Update UI
                userAvatar.textContent = user.name ? user.name.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase();
                appContainer.style.display = 'flex';
                hideModal('loginModal');
                
                // Load user data
                loadUserData();
                
                // Add welcome message
                addMessage('assistant', `Welcome back, ${user.name || 'User'}! How can I assist you today?`);
                
                // Create new session if none exist
                if (!currentSessionID) {
                    createNewSession();
                }
            } else {
                addMessage('assistant', 'Login failed: Invalid email or password', true);
            }
        }

        function handleSignup(e) {
            e.preventDefault();
            const name = document.getElementById('signupName').value;
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            
            // Get existing users
            const users = JSON.parse(localStorage.getItem('aurora_users')) || [];
            
            // Check if user already exists
            if (users.some(u => u.email === email)) {
                addMessage('assistant', 'Signup failed: Email already in use', true);
                return;
            }
            
            // Create new user
            const newUser = {
                id: Date.now().toString(),
                name,
                email,
                password,
                createdAt: new Date().toISOString()
            };
            
            // Save user
            users.push(newUser);
            localStorage.setItem('aurora_users', JSON.stringify(users));
            
            // Set as current user
            currentUser = {
                email: newUser.email,
                name: newUser.name,
                id: newUser.id
            };
            localStorage.setItem('aurora_user', JSON.stringify(currentUser));
            
            // Create user preferences
            userPreferences = {
                response_length: "medium",
                formality: "neutral",
                topics: [],
                last_session: null,
                ongoing_topics: {},
                preferred_ai: "hybrid",
                reasoning_mode: "balanced"
            };
            localStorage.setItem(`aurora_preferences_${currentUser.id}`, JSON.stringify(userPreferences));
            
            // Update UI
            userAvatar.textContent = name ? name.charAt(0).toUpperCase() : email.charAt(0).toUpperCase();
            hideModal('signupModal');
            
            // Add welcome message
            addMessage('assistant', `Welcome to Aurora, ${name || 'User'}! How can I assist you today?`);
            
            // Create first session
            createNewSession();
        }

        function logout() {
            // Clear current user
            currentUser = null;
            localStorage.removeItem('aurora_user');
            
            // Clear conversation
            conversationHistory = [];
            chatMessages.innerHTML = '';
            
            // Show login modal
            showLoginModal();
        }

        function toggleUserMenu() {
            userMenu.classList.toggle('active');
        }

        // Close user menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!userAvatar.contains(e.target) && !userMenu.contains(e.target)) {
                userMenu.classList.remove('active');
            }
        }); 

        function showLoginModal() {
            hideModal('signupModal');
            showModal('loginModal');
        }

        function showSignupModal() {
            hideModal('loginModal');
            showModal('signupModal');
        }  

        // Load user data from localStorage
        function loadUserData() {
            if (!currentUser) return;
            
            // Load preferences
            const savedPreferences = localStorage.getItem(`aurora_preferences_${currentUser.id}`);
            if (savedPreferences) {
                userPreferences = JSON.parse(savedPreferences);
                updatePreferencesUI();
            }
            
            // Load theme preference
            const savedTheme = localStorage.getItem('aurora_theme');
            if (savedTheme) {
                currentTheme = savedTheme;
                changeTheme(savedTheme);
                themeSelector.value = savedTheme;
            }
        }

        // Update preferences UI
        function updatePreferencesUI() {
            if (responseLength) responseLength.value = userPreferences.response_length;
            if (formalityLevel) formalityLevel.value = userPreferences.formality;
            if (preferredAI) preferredAI.value = userPreferences.preferred_ai;
            if (favoriteTopics) favoriteTopics.value = userPreferences.topics.join(', ');
            if (reasoningMode) reasoningMode.value = userPreferences.reasoning_mode;
        }

        // Add a message to the chat with enhanced formatting
        function addMessage(sender, content, isError = false, isSystem = false, showTyping = false) {
            if (showTyping) {
                showTypingIndicator();
                // Wait a bit before showing the actual message to simulate typing
                setTimeout(() => {
                    hideTypingIndicator();
                    addMessage(sender, content, isError, isSystem, false);
                }, 1500);
                return;
            }
            
            // Process content for formatting
            let processedContent = formatMessageContent(content);
            
            const messageDiv = document.createElement('div');
            
            if (isSystem) {
                messageDiv.className = 'message system-message';
            } else if (isError) {
                messageDiv.className = 'message error-message';
            } else {
                messageDiv.className = `message ${sender}-message`;
            }
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="message-content">${processedContent}</div>
                <div class="message-meta">
                    <span>${sender === 'user' ? 'You' : 'Aurora'}</span>
                    <span>${timestamp}</span>
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();

            // Add to conversation history if not a system message
            if (!isSystem) {
                const newMessage = {
                    role: sender,
                    content: content, // Store original content
                    timestamp: new Date().toISOString()
                };
                
                conversationHistory.push(newMessage);
                
                // Update the current session's history
                if (currentSessionID && chatSessions[currentSessionID]) {
                    chatSessions[currentSessionID].history = conversationHistory;
                    chatSessions[currentSessionID].lastActive = new Date().toISOString();
                    
                    // Update session title if it's the first user message
                    if (sender === 'user' && chatSessions[currentSessionID].history.length === 1) {
                        const firstFewWords = content.split(' ').slice(0, 5).join(' ');
                        chatSessions[currentSessionID].title = firstFewWords.length > 30 ? 
                            firstFewWords.substring(0, 30) + '...' : firstFewWords;
                        document.querySelector('.chat-title').textContent = chatSessions[currentSessionID].title;
                    }
                    
                    saveChatSessions();
                }
            }
        }

        // Format message content with proper HTML formatting
        function formatMessageContent(content) {
            // Convert markdown-style bold (**text**) to HTML
            let formatted = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert markdown-style italic (*text*) to HTML
            formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Convert code blocks (```language\ncode\n```) to HTML
            formatted = formatted.replace(/```(\w*)\n([\s\S]*?)\n```/g, function(match, lang, code) {
                const blockId = 'code-' + Math.random().toString(36).substr(2, 9);
                return `
                    <div class="code-block">
                        <div class="code-header">
                            <span>${lang || 'code'}</span>
                            <button class="copy-btn" onclick="copyToClipboard('${blockId}')">Copy</button>
                        </div>
                        <pre id="${blockId}">${escapeHtml(code)}</pre>
                    </div>
                `;
            });
            
            // Convert inline code (`code`) to HTML
            formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Convert newlines to <br> and paragraphs
            formatted = formatted.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>');
            formatted = `<p>${formatted}</p>`;
            
            // Check for image generation prompts
            if (content.includes('![generate:') && CONFIG.stabilityai_key) {
                const imagePromptMatch = content.match(/!\[generate:(.*?)\]/);
                if (imagePromptMatch && imagePromptMatch[1]) {
                    const prompt = imagePromptMatch[1].trim();
                    formatted += `
                        <button class="generate-image-btn" onclick="generateImage('${escapeHtml(prompt)}')">
                            Generate Image for "${escapeHtml(prompt)}"
                        </button>
                    `;
                }
            }
            
            return formatted;
        }

        // Escape HTML special characters
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Copy code to clipboard
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                const text = element.textContent;
                navigator.clipboard.writeText(text).then(() => {
                    const buttons = document.querySelectorAll('.copy-btn');
                    buttons.forEach(btn => {
                        if (btn.textContent === 'Copied!') {
                            btn.textContent = 'Copy';
                            btn.classList.remove('copied');
                        }
                    });
                    
                    const button = element.parentElement.querySelector('.copy-btn');
                    if (button) {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }
                });
            }
        }

        // Generate image from prompt using Stability AI
        async function generateImage(prompt) {
            try {
                addMessage('system', `Generating image for: "${prompt}"`, false, true);
                
                // In a real implementation, you would call the Stability AI API
                // This is a mock implementation for demonstration
                const mockImageUrl = `https://source.unsplash.com/random/600x400/?${encodeURIComponent(prompt)}`;
                
                // Display the generated image
                const imageDiv = document.createElement('div');
                imageDiv.innerHTML = `
                    <img src="${mockImageUrl}" alt="${prompt}" class="generated-image">
                    <div class="image-prompt">Generated from prompt: "${prompt}"</div>
                `;
                chatMessages.appendChild(imageDiv);
                scrollToBottom();
                
                // Add to conversation history
                conversationHistory.push({
                    role: 'assistant',
                    content: `![generated image](${mockImageUrl}) for "${prompt}"`,
                    timestamp: new Date().toISOString()
                });
                
                // Update session history
                if (currentSessionID) {
                    chatSessions[currentSessionID].history = conversationHistory;
                    saveChatSessions();
                }
                
            } catch (error) {
                console.error('Image generation error:', error);
                addMessage('assistant', "I couldn't generate that image. Please try again later.", true);
            }
        }

        // Show typing indicator
        function showTypingIndicator() {
            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = `
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            `;
            chatMessages.appendChild(typingDiv);
            scrollToBottom();
        }

        // Hide typing indicator
        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        // Scroll chat to bottom
        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Send message handler
        function sendMessage() {
            const message = messageInput.value.trim();
            if (message) {
                addMessage('user', message);
                messageInput.value = '';
                processCommand(message);
            }
        }

        // Handle Enter key press
        function handleKeyPress(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        }

        // Handle file upload
        async function handleFileUpload(files) {
            if (!files || files.length === 0) return;
            
            const file = files[0];
            const fileType = SUPPORTED_FILE_TYPES[file.type];
            
            if (!fileType) {
                addMessage('assistant', 'Sorry, I don\'t support this file type.', true);
                return;
            }
            
            addMessage('user', `[Uploaded ${fileType} file: ${file.name}]`, false, false);
            
            try {
                const textContent = await extractTextFromFile(file, fileType);
                
                // Store file context for future questions
                currentFileContext = {
                    name: file.name,
                    type: fileType,
                    content: textContent,
                    uploadedAt: new Date().toISOString()
                };
                
                // For large files, we process in chunks
                if (textContent.length > 2000) {
                    const summary = await summarizeContent(textContent, file.name);
                    addMessage('assistant', `I've processed your ${fileType} file (${file.name}). Here's a summary:`, false, false, true);
                    addMessage('assistant', summary);
                } else {
                    addMessage('assistant', `Here's the content of your ${fileType} file (${file.name}):`, false, false, true);
                    addMessage('assistant', textContent);
                }
                
                // Add file context indicator
                const contextIndicator = document.createElement('div');
                contextIndicator.className = 'file-context';
                contextIndicator.textContent = `Current context: ${file.name}`;
                chatMessages.appendChild(contextIndicator);
                
            } catch (error) {
                console.error('File processing error:', error);
                addMessage('assistant', 'I encountered an error processing your file.', true);
            }
        }

        // Enhanced extract text from different file types
        async function extractTextFromFile(file, fileType) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async (event) => {
                    try {
                        let content;
                        
                        switch(fileType) {
                            case 'PDF':
                                content = await extractTextFromPDF(event.target.result);
                                break;
                            case 'Word':
                                content = await extractTextFromWord(event.target.result);
                                break;
                            case 'Text':
                                content = event.target.result;
                                break;
                            case 'Image':
                                content = await extractTextFromImage(event.target.result);
                                break;
                            default:
                                content = "Unknown file type content";
                        }
                        
                        resolve(content);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(reader.error);
                
                if (fileType === 'Text') {
                    reader.readAsText(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        // Extract text from PDF using PDF.js
        async function extractTextFromPDF(data) {
            try {
                const pdf = await pdfjsLib.getDocument(data).promise;
                let fullText = '';
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const textItems = textContent.items.map(item => item.str);
                    fullText += textItems.join(' ') + '\n';
                }
                
                return fullText;
            } catch (error) {
                console.error('PDF extraction error:', error);
                throw error;
            }
        }

        // Extract text from Word documents using mammoth.js
        async function extractTextFromWord(arrayBuffer) {
            try {
                const result = await mammoth.extractRawText({ arrayBuffer });
                return result.value;
            } catch (error) {
                console.error('Word extraction error:', error);
                throw error;
            }
        }

        // Placeholder for image OCR (would use Tesseract.js in production)
        async function extractTextFromImage(imageData) {
            return "Image content processing would be implemented with Tesseract.js in production";
        }

        // Summarize large content
        async function summarizeContent(content, filename) {
            // In a real implementation, we would use AI to summarize
            return `Summary of ${filename}:\n\n${content.substring(0, 500)}... [content truncated for display]`;
        }

        // Process user commands with file context awareness
        function processCommand(command, isVoice = false) {
            const commandLower = command.toLowerCase();
            
            // Check if question is about current file
            if (currentFileContext && (commandLower.includes('file') || commandLower.includes('document') || 
                commandLower.includes(currentFileContext.name.toLowerCase()))) {
                return processFileQuery(command, isVoice);
            }
            
            // Check for ongoing topics
            const ongoingResponse = checkOngoingTopics(command);
            if (ongoingResponse) {
                addMessage('assistant', ongoingResponse, false, false, true);
                if (isVoice) speak(ongoingResponse);
                return;
            }
            
            // Handle specific commands
            if (commandLower.includes('open google')) {
                openGoogle();
            } else if (commandLower.includes('open youtube')) {
                openYoutube();
            } else if (commandLower.includes('weather in') || commandLower.includes('weather for')) {
                const city = commandLower.replace('weather in', '').replace('weather for', '').trim();
                fetchWeather(city);
            } else if (commandLower.includes('news')) {
                fetchNews();
            } else if (commandLower.includes('play')) {
                const query = commandLower.replace('play', '').trim();
                playYoutube(query);
                if (isVoice) speak(`Playing ${query} on YouTube`);
            } else if (commandLower.includes('search')) {
                const query = commandLower.replace('search', '').trim();
                searchGoogle(query);
                if (isVoice) speak(`Searching Google for ${query}`);
            } else if (commandLower.includes('webcam') || commandLower.includes('camera')) {
                showModal('webcamModal');
            } else {
                getAIResponse(command, isVoice);
            }
        }

        async function processFileQuery(query, isVoice = false) {
            try {
                const reasoningMode = document.getElementById('reasoningMode').value;
                const prompt = `The user asked this question about a file they uploaded: "${query}"\n\n` +
                               `File name: ${currentFileContext.name}\n` +
                               `File type: ${currentFileContext.type}\n` +
                               `File content:\n${currentFileContext.content.substring(0, 10000)}\n\n` +
                               `Please answer the question based on the file content.`;
                
                const response = await aiService.getAIResponse(prompt, conversationHistory, reasoningMode);
                
                addMessage('assistant', response, false, false, true);
                
                if (isVoice) {
                    speak(response);
                }
            } catch (error) {
                console.error('File query error:', error);
                addMessage('assistant', "I couldn't answer that question about the file.", true);
            }
        }

        // Check for ongoing topics in conversation
        function checkOngoingTopics(command) {
            for (const [topic, context] of Object.entries(userPreferences.ongoing_topics)) {
                if (command.toLowerCase().includes(topic.toLowerCase())) {
                    let response = `Continuing our discussion about ${topic}. ${context.last_response}`;
                    
                    if (command.toLowerCase().includes('more') || command.toLowerCase().includes('details')) {
                        if (context.more_info) {
                            return `Here's more about ${topic}: ${context.more_info}`;
                        } else {
                            return `I don't have additional details about ${topic} right now.`;
                        }
                    }
                    
                    return response;
                }
            }
            return null;
        }

        // AI Service Class with enhanced reasoning capabilities
        class AIService {
            constructor() {
                this.config = {
                    gemini: {
                        apiKey: CONFIG.genai_key,
                        endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"
                    },
                    anthropic: {
                        apiKey: CONFIG.anthropic_key,
                        endpoint: "https://api.anthropic.com/v1/messages",
                        version: "2023-06-01"
                    }
                };
                this.reasoningMode = 'balanced';
            }
            
            setReasoningMode(mode) {
                this.reasoningMode = mode;
            }
            
            async getDeepResponse(prompt, conversationHistory = []) {
                const loadingId = this.showLoadingIndicator('Engaging deep reasoning...');
                
                try {
                    // Step 1: Initial analysis
                    const analysisPrompt = `Analyze this request thoroughly. Break it down into key components and identify:\n` +
                                         `1. The core question or request\n` +
                                         `2. Relevant context from conversation history\n` +
                                         `3. Potential approaches to answer\n\n` +
                                         `Request: "${prompt}"\n\n` +
                                         `Provide your analysis in clear sections.`;
                    
                    const analysis = await this.getAnthropicResponse(analysisPrompt, conversationHistory);
                    
                    // Step 2: Knowledge gathering
                    const knowledgePrompt = `Based on this analysis, what specific knowledge or information would be needed to properly respond?\n\n` +
                                          `Analysis:\n${analysis}\n\n` +
                                          `List the key information requirements.`;
                    
                    const knowledgeRequirements = await this.getGeminiResponse(knowledgePrompt, conversationHistory);
                    
                    // Step 3: Response formulation
                    const responsePrompt = `Using this analysis and knowledge requirements, formulate a comprehensive response:\n\n` +
                                         `Analysis:\n${analysis}\n\n` +
                                         `Knowledge Needed:\n${knowledgeRequirements}\n\n` +
                                         `Provide a detailed, well-structured answer.`;
                    
                    const finalResponse = await this.getHybridResponse(responsePrompt, conversationHistory);
                    
                    this.hideLoadingIndicator(loadingId);
                    
                    return ` Deep Analysis:\n${analysis}\n\n` +
                           ` Knowledge Gathered:\n${knowledgeRequirements}\n\n` +
                           ` Final Answer:\n${finalResponse}`;
                } catch (error) {
                    this.hideLoadingIndicator(loadingId);
                    console.error('Deep reasoning error:', error);
                    // Fall back to standard response if deep reasoning fails
                    return this.getHybridResponse(prompt, conversationHistory);
                }
            } 
        
            async getAIResponse(prompt, conversationHistory, reasoningMode = 'balanced') {
                switch(reasoningMode) {
                    case 'fast':
                        return this.getGeminiResponse(prompt, conversationHistory);
                    case 'deep':
                        return this.getDeepResponse(prompt, conversationHistory);
                    case 'balanced':
                    default:
                        return this.getHybridResponse(prompt, conversationHistory);
                }
            }

            async getGeminiResponse(prompt, conversationHistory = []) {
                try {
                    const loadingId = this.showLoadingIndicator();
                    
                    const response = await fetch(`${this.config.gemini.endpoint}?key=${this.config.gemini.apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [
                                ...conversationHistory.map(msg => ({
                                    role: msg.role === 'user' ? 'user' : 'model',
                                    parts: [{ text: msg.content }]
                                })),
                                {
                                    role: 'user',
                                    parts: [{ text: prompt }]
                                }
                            ],
                            generationConfig: {
                                temperature: 0.7,
                                topP: 0.9,
                                maxOutputTokens: userPreferences.response_length === 'short' ? 500 : 
                                              userPreferences.response_length === 'medium' ? 1000 : 2000
                            }
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Gemini API error: ${response.status}`);
                    }

                    const data = await response.json();
                    this.hideLoadingIndicator(loadingId);
                    
                    if (!data.candidates || !data.candidates[0].content.parts[0].text) {
                        throw new Error('Invalid response format from Gemini');
                    }

                    return data.candidates[0].content.parts[0].text;
                } catch (error) {
                    this.hideLoadingIndicator(loadingId);
                    console.error('Gemini API error:', error);
                    throw error;
                }
            }

            async getAnthropicResponse(prompt, conversationHistory = []) {
                try {
                    const loadingId = this.showLoadingIndicator();
                    
                    const response = await fetch(this.config.anthropic.endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.config.anthropic.apiKey,
                            'anthropic-version': this.config.anthropic.version
                        },
                        body: JSON.stringify({
                            model: "claude-3-7-sonnet-20250219", 
                            max_tokens: userPreferences.response_length === 'short' ? 500 : 
                                      userPreferences.response_length === 'medium' ? 1000 : 2000,
                            temperature: 0.7,
                            system: `You are Aurora, a helpful AI assistant. Respond in a ${userPreferences.formality} tone.`,
                            messages: [
                                ...conversationHistory.map(msg => ({
                                    role: msg.role === 'user' ? 'user' : 'assistant',
                                    content: msg.content
                                })),
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Anthropic API error: ${response.status}`);
                    }

                    const data = await response.json();
                    this.hideLoadingIndicator(loadingId);
                    
                    if (!data.content || !data.content[0].text) {
                        throw new Error('Invalid response format from Anthropic');
                    }

                    return data.content[0].text;
                } catch (error) {
                    this.hideLoadingIndicator(loadingId);
                    console.error('Anthropic API error:', error);
                    throw error;
                }
            }

            async getHybridResponse(prompt, conversationHistory = []) {
                try {
                    const loadingId = this.showLoadingIndicator('Consulting multiple AI models...');
                    
                    const [geminiResp, anthropicResp] = await Promise.all([
                        this.getGeminiResponse(prompt, conversationHistory).catch(e => {
                            console.error('Gemini error:', e);
                            return null;
                        }),
                        this.getAnthropicResponse(prompt, conversationHistory).catch(e => {
                            console.error('Anthropic error:', e);
                            return null;
                        })
                    ]);

                    this.hideLoadingIndicator(loadingId);
                    
                    // If only one response succeeded
                    if (!geminiResp && !anthropicResp) {
                        throw new Error('Both AI services failed to respond');
                    }
                    if (!geminiResp) return anthropicResp;
                    if (!anthropicResp) return geminiResp;

                    // Combine responses intelligently based on device type
                    if (isMobile) {
                        // For mobile, prefer the shorter response
                        return geminiResp.length < anthropicResp.length ? geminiResp : anthropicResp;
                    } else {
                        // For desktop, combine both responses
                        return `Here are perspectives from both AI models:\n\n` +
                               `Gemini:\n${geminiResp}\n\n` +
                               `Claude:\n${anthropicResp}`;
                    }
                } catch (error) {
                    console.error('Hybrid response error:', error);
                    throw error;
                }
            }

            showLoadingIndicator(message = 'Thinking...') {
                const id = 'loading-' + Date.now();
                const loadingDiv = document.createElement('div');
                loadingDiv.id = id;
                loadingDiv.className = 'message system-message';
                loadingDiv.innerHTML = `
                    <div class="message-content">
                        <i class="fas fa-spinner fa-spin spinner"></i> ${message}
                    </div>
                `;
                document.getElementById('chatMessages').appendChild(loadingDiv);
                scrollToBottom();
                return id;
            }

            hideLoadingIndicator(id) {
                const element = document.getElementById(id);
                if (element) {
                    element.remove();
                }
            }
        }

        // Initialize AI Service
        const aiService = new AIService();

        // Get AI response
        async function getAIResponse(text, isVoice = false) {
            try {
                const reasoningMode = document.getElementById('reasoningMode').value;
                const prompt = buildContextAwarePrompt(text);
                
                const response = await aiService.getAIResponse(prompt, conversationHistory, reasoningMode);
                
                addMessage('assistant', response, false, false, true);
                extractOngoingTopics(text, response);
                
                if (isVoice) {
                    speak(response);
                }
            } catch (error) {
                console.error('AI response error:', error);
                addMessage('assistant', "I'm sorry, I encountered an error processing your request.", true);
            }
        }

        // Build context-aware prompt for AI
        function buildContextAwarePrompt(userInput) {
            const promptParts = [
                `You are Aurora, a helpful AI assistant. Respond in a ${userPreferences.formality} tone.`,
                `User preferences: ${JSON.stringify(userPreferences)}`,
                "Current conversation:"
            ];
            
            const recentHistory = conversationHistory.slice(-6);
            for (const exchange of recentHistory) {
                const role = exchange.role === 'user' ? 'User' : 'Assistant';
                promptParts.push(`${role}: ${exchange.content}`);
            }
            
            if (Object.keys(userPreferences.ongoing_topics).length > 0) {
                promptParts.push("\nOngoing topics:");
                for (const [topic, context] of Object.entries(userPreferences.ongoing_topics)) {
                    promptParts.push(`- ${topic}: ${context.last_response}`);
                }
            }
            
            promptParts.push(`\nUser: ${userInput}`);
            promptParts.push("Assistant:");
            
            return promptParts.join('\n');
        }

        // Extract ongoing topics from conversation
        function extractOngoingTopics(userInput, aiResponse) {
            const topicsToCheck = ["travel", "book", "movie", "music", "project", "work", "study", "research"];
            let topicFound = false;
            
            for (const topic of topicsToCheck) {
                if (userInput.toLowerCase().includes(topic.toLowerCase())) {
                    userPreferences.ongoing_topics[topic] = {
                        last_input: userInput,
                        last_response: aiResponse,
                        timestamp: Date.now()
                    };
                    topicFound = true;
                    break;
                }
            }
            
            if (topicFound) {
                savePreferences();
            }
        }

        // Quick action handlers
        function handleQuickAction(action) {
            switch (action) {
                case 'google':
                    openGoogle();
                    break;
                case 'youtube':
                    openYoutube();
                    break;
                case 'weather':
                    showModal('weatherModal');
                    break;
                case 'news':
                    fetchNews();
                    break;
                case 'webcam':
                    showModal('webcamModal');
                    break;
                case 'settings':
                    showModal('settingsModal');
                    break;
            }
        }

        function openGoogle() {
            window.open('https://google.com', '_blank');
            addMessage('assistant', 'Opening Google.');
        }

        function openYoutube() {
            window.open('https://youtube.com', '_blank');
            addMessage('assistant', 'Opening YouTube.');
        }

        function playYoutube(query) {
            window.open(`https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`, '_blank');
            addMessage('assistant', `Playing ${query} on YouTube`);
            updateTopicPreference('music', query);
        }

        function searchGoogle(query) {
            window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank');
            addMessage('assistant', `Searching Google for ${query}`);
            updateTopicPreference('search', query);
        }

        // Fetch weather data
        async function fetchWeather(city) {
            if (!city) {
                city = document.getElementById('weatherCity').value;
                if (!city) return;
            }
            
            const url = `https://api.weatherapi.com/v1/current.json?key=${CONFIG.weather_api}&q=${encodeURIComponent(city)}&aqi=no`;
            
            try {
                addMessage('system', 'Fetching weather data...', false, true);
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Weather API error');
                
                const weatherData = await response.json();
                const weatherInfo = `The current temperature in ${city} is ${weatherData.current.temp_c}C with ${weatherData.current.condition.text}.`;
                
                addMessage('assistant', weatherInfo, false, false, true);
                speak(weatherInfo);
                updateTopicPreference('weather', city);
                
                // Update weather modal if open
                const weatherResult = document.getElementById('weatherResult');
                if (weatherResult) {
                    weatherResult.innerHTML = `
                        <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.1); border-radius: 8px;">
                            <h3 style="margin-bottom: 10px;">Weather in ${city}</h3>
                            <p>Temperature: ${weatherData.current.temp_c}C (${weatherData.current.temp_f}F)</p>
                            <p>Condition: ${weatherData.current.condition.text}</p>
                            <p>Humidity: ${weatherData.current.humidity}%</p>
                            <p>Wind: ${weatherData.current.wind_kph} km/h</p>
                        </div>
                    `;
                }
            } catch (error) {
                addMessage('assistant', 'Unable to retrieve weather data.', true);
            }
        }

        // Fetch news
        async function fetchNews() {
            const url = `https://newsapi.org/v2/top-headlines?country=us&apiKey=${CONFIG.newsapi}`;
            
            try {
                addMessage('system', 'Fetching news headlines...', false, true);
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('News API error');
                
                const data = await response.json();
                const articles = data.articles || [];
                
                if (articles.length > 0) {
                    addMessage('assistant', 'Here are the latest news headlines:', false, false, true);
                    
                    for (let i = 0; i < Math.min(5, articles.length); i++) {
                        addMessage('assistant', articles[i].title);
                    }
                    
                    updateTopicPreference('news');
                } else {
                    addMessage('assistant', 'No news found at the moment.', true);
                }
            } catch (error) {
                addMessage('assistant', 'I can\'t fetch news right now.', true);
            }
        }

        // Update user topic preferences
        function updateTopicPreference(category, value = null) {
            if (!userPreferences.topics.includes(category)) {
                userPreferences.topics.push(category);
            }
            
            if (category === 'weather' && value) {
                if (!userPreferences.locations) {
                    userPreferences.locations = [];
                }
                if (!userPreferences.locations.includes(value)) {
                    userPreferences.locations.push(value);
                }
            }
            
            savePreferences();
        }

        // Check for returning user
        function checkReturningUser() {
            if (userPreferences.last_session) {
                const lastTime = userPreferences.last_session;
                const currentTime = Date.now();
                
                if (currentTime - lastTime > 3600000) { // 1 hour
                    let lastTopic = null;
                    const ongoingTopics = Object.keys(userPreferences.ongoing_topics);
                    
                    if (ongoingTopics.length > 0) {
                        lastTopic = ongoingTopics[0];
                    }
                    
                    const welcomeBack = lastTopic 
                        ? `Welcome back! We were last discussing ${lastTopic}. Would you like to continue?`
                        : 'Welcome back! How can I assist you today?';
                    
                    addMessage('assistant', welcomeBack);
                    speak(welcomeBack);
                }
            }
            
            userPreferences.last_session = Date.now();
            savePreferences();
        }

        // Voice input functions
        function setupSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('Speech recognition not supported');
                voiceBtn.style.display = 'none';
                return;
            }
            
            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.continuous = false;
            recognition.interimResults = false;
            
            recognition.onstart = function() {
                isListening = true;
                voiceBtn.classList.add('active');
                addMessage('system', 'Listening...', false, true);
            };
            
            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                addMessage('user', transcript);
                processCommand(transcript, true);
            };
            
            recognition.onerror = function(event) {
                addMessage('assistant', 'Sorry, I couldn\'t understand that.', true);
            };
            
            recognition.onend = function() {
                isListening = false;
                voiceBtn.classList.remove('active');
            };
        }

        function toggleVoiceInput() {
            if (!isListening) {
                recognition.start();
            } else {
                recognition.stop();
            }
        }

        // Speech synthesis functions
        function setupSpeechSynthesis() {
            // Load voices when they become available
            speechSynthesis.onvoiceschanged = function() {
                voices = speechSynthesis.getVoices();
                const voiceSelect = document.getElementById('voiceSelect');
                
                if (voiceSelect) {
                    voiceSelect.innerHTML = '';
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = 'default';
                    defaultOption.textContent = 'Default';
                    voiceSelect.appendChild(defaultOption);
                    
                    // Add available voices
                    voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.textContent = `${voice.name} (${voice.lang})`;
                        option.setAttribute('data-name', voice.name);
                        option.setAttribute('data-lang', voice.lang);
                        voiceSelect.appendChild(option);
                    });
                    
                    // Try to select a reasonable default voice
                    const preferredVoice = voices.find(v => 
                        v.lang.includes('en') && 
                        v.name.includes('Google') || 
                        v.name.includes('Samantha') || 
                        v.name.includes('Alex')
                    );
                    
                    if (preferredVoice) {
                        voiceSelect.value = preferredVoice.name;
                    }
                }
            };
            
            // Chrome needs this to populate voices
            speechSynthesis.getVoices();
        }

        function speak(text) {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Apply user preferences
            const speechRate = parseFloat(document.getElementById('speechRate')?.value) || 1;
            const speechVolume = parseFloat(document.getElementById('speechVolume')?.value) || 0.8;
            const voiceSelect = document.getElementById('voiceSelect');
            
            utterance.rate = speechRate;
            utterance.volume = speechVolume;
            
            if (voiceSelect && voiceSelect.value !== 'default') {
                const selectedOption = voiceSelect.selectedOptions[0];
                if (selectedOption) {
                    const selectedVoice = voices.find(voice => 
                        voice.name === selectedOption.getAttribute('data-name') &&
                        voice.lang === selectedOption.getAttribute('data-lang')
                    );
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                    }
                }
            }
            
            speechSynthesis.speak(utterance);
        }

        // Webcam functions
        function startWebcam() {
            if (isWebcamActive) return;
            
            webcamMode = webcamModeSelect.value;
            
            // Check if browser supports mediaDevices
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                webcamStatus.textContent = 'Webcam not supported in this browser';
                return;
            }
            
            navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                .then(function(stream) {
                    webcamStream = stream;
                    webcamVideo.srcObject = stream;
                    isWebcamActive = true;
                    
                    // Update UI
                    startWebcamBtn.disabled = true;
                    stopWebcamBtn.disabled = false;
                    webcamStatus.textContent = 'Webcam is active. Say "Hello Aurora" to start interacting.';
                    
                    // Start voice recognition if in voice mode
                    if (webcamMode === 'voice' || webcamMode === 'both') {
                        setupWebcamVoiceRecognition();
                    }
                    
                    // Start gesture recognition if in gesture mode
                    if (webcamMode === 'gesture' || webcamMode === 'both') {
                        setupGestureRecognition();
                    }
                })
                .catch(function(err) {
                    console.error('Error accessing webcam:', err);
                    webcamStatus.textContent = 'Error accessing webcam: ' + err.message;
                });
        }

        function stopWebcam() {
            if (!isWebcamActive) return;
            
            // Stop all tracks in the stream
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            
            // Clear video source
            webcamVideo.srcObject = null;
            isWebcamActive = false;
            
            // Stop any ongoing recognition
            if (recognition && isListening) {
                recognition.stop();
            }
            
            // Clear any intervals
            if (webcamInterval) {
                clearInterval(webcamInterval);
                webcamInterval = null;
            }
            
            // Update UI
            startWebcamBtn.disabled = false;
            stopWebcamBtn.disabled = true;
            webcamStatus.textContent = 'Webcam stopped. Click "Start Webcam" to begin again.';
        }

        function setupWebcamVoiceRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                webcamStatus.textContent = 'Voice recognition not supported in this browser';
                return;
            }
            
            // Create new recognition instance for webcam
            const webcamRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            webcamRecognition.continuous = true;
            webcamRecognition.interimResults = false;
            
            webcamRecognition.onstart = function() {
                webcamStatus.textContent = 'Listening for voice commands...';
            };
            
            webcamRecognition.onresult = function(event) {
                const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase();
                
                // Check for wake word
                if (transcript.includes('hello aurora') || transcript.includes('hey aurora')) {
                    webcamStatus.textContent = 'Aurora is listening...';
                    
                    // Process the command after wake word
                    const command = transcript.split('aurora')[1].trim();
                    if (command) {
                        addMessage('user', command);
                        processCommand(command, true);
                    }
                }
            };
            
            webcamRecognition.onerror = function(event) {
                console.error('Voice recognition error:', event.error);
                webcamStatus.textContent = 'Voice recognition error: ' + event.error;
            };
            
            webcamRecognition.start();
        }

        function setupGestureRecognition() {
            // This is a placeholder for actual gesture recognition
            // In a real implementation, you would use a library like TensorFlow.js with a handpose model
            webcamStatus.textContent = 'Gesture recognition is active. Wave to get attention.';
            
            // Mock gesture recognition for demonstration
            webcamInterval = setInterval(() => {
                // In a real app, this would analyze the video feed for gestures
                if (Math.random() < 0.1) { // 10% chance of detecting a "wave"
                    webcamStatus.textContent = 'Wave detected! Aurora is listening...';
                    speak("I noticed you waving! How can I help you?");
                }
            }, 2000);
        }

        // Modal functions
        function showModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }

        function hideModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function showHistoryModal() {
            updateHistoryModal();
            showModal('historyModal');
        }

        function showPreferencesModal() {
            // Ensure UI reflects current preferences
            responseLength.value = userPreferences.response_length;
            formalityLevel.value = userPreferences.formality;
            preferredAI.value = userPreferences.preferred_ai;
            favoriteTopics.value = userPreferences.topics.join(', ');
            reasoningMode.value = userPreferences.reasoning_mode || 'balanced';
            
            showModal('preferencesModal');
        }

        // Theme functions
        function changeTheme(theme) {
            document.body.classList.remove("light", "dark", "blue", "green");
            document.body.classList.add(theme);
            currentTheme = theme;
            
            // Save theme preference
            localStorage.setItem('aurora_theme', theme);
        }

        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // Clear chat history
        function clearChat() {
            if (confirm('Are you sure you want to clear the current conversation?')) {
                conversationHistory = [];
                chatMessages.innerHTML = '';
                
                // Update session history
                if (currentSessionID) {
                    chatSessions[currentSessionID].history = [];
                    saveChatSessions();
                }
                
                addMessage('assistant', 'Conversation cleared. How can I help you now?');
            }
        }

        // Save settings
        function saveSettings() {
            // Settings are applied immediately, just close the modal
            hideModal('settingsModal');
            addMessage('assistant', 'Settings updated successfully!');
        }

        // Save preferences
        function savePreferences(showMessage = false) {
            if (!currentUser) return;
            
            userPreferences.response_length = responseLength.value;
            userPreferences.formality = formalityLevel.value;
            userPreferences.preferred_ai = preferredAI.value;
            userPreferences.reasoning_mode = reasoningMode.value;
            userPreferences.topics = favoriteTopics.value.split(',').map(t => t.trim()).filter(t => t);
            
            localStorage.setItem(`aurora_preferences_${currentUser.id}`, JSON.stringify(userPreferences));
            
            if (showMessage) {
                addMessage('assistant', 'Preferences updated successfully!');
            }
        }

        function ensureUIVisible() {
            appContainer.style.display = 'flex';
            appContainer.style.opacity = 1;
            appContainer.style.visibility = 'visible';
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script> 
</body>
</html> 
